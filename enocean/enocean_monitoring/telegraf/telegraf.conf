# Telegraf Configuration for EnOcean Sensors

[global_tags]

  deployment = "enocean-monitoring"

[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = ""
  hostname = ""
  omit_hostname = false

###############################################################################
#                            OUTPUT PLUGINS                                  #
###############################################################################

# InfluxDB v2 output plugin
[[outputs.influxdb_v2]]
  urls = ["http://influxdb:8086"]
  token = "$INFLUX_TOKEN"
  organization = "$INFLUX_ORG"
  bucket = "$INFLUX_BUCKET"
  timeout = "5s"

###############################################################################
#                            INPUT PLUGINS                                   #
###############################################################################

# MQTT Consumer for EnOcean sensor data
[[inputs.mqtt_consumer]]
  servers = ["tcp://localhost:11883"]
  topics = [
    "enocean/sensors/+",
  ]
  data_format = "json"
  json_time_key = "timestamp"
  json_time_format = "unix"
  tag_keys = [
    "device_id",
    "type",
    "eep_profile",
    "pattern",
    "button_name",
    "button_combination"
  ]
  json_string_fields = [
    "magnet_contact",
    "button_description",
    "action"    
  ]



# Parse temperature and humidity for multi-sensor devices
[[processors.converter]]
  [processors.converter.tags]
    string = ["device_id", "type", "eep_profile"]
  [processors.converter.fields]
    float = ["temperature_c", "temperature_f", "humidity_percent", "illumination_lx"]
    integer = ["acceleration_status", "pressed", "button_a_pressed", "button_b_pressed", "button_c_pressed", "button_d_pressed"]

# Add measurement names based on sensor type
[[processors.regex]]
  namepass = ["mqtt_consumer"]
  [[processors.regex.tags]]
    key = "type"
    pattern = "^(.*)$"
    replacement = "enocean_${1}"
    result_key = "measurement_name"


[[processors.starlark]]
  namepass = ["mqtt_consumer"]
  source = '''
def apply(metric):
    # List of field patterns to remove
    fields_to_remove = []
    
    for field_name in metric.fields:
        # Remove debug and raw data fields
        if (field_name == "raw_data" or 
            field_name.startswith("raw_bits") or
            field_name.startswith("signal_quality") or
            field_name.startswith("debug_raw_values")):
            fields_to_remove.append(field_name)
    
    # Remove the unwanted fields
    for field in fields_to_remove:
        metric.fields.pop(field, None)
    
    return metric
  '''

  
# Rename measurements
[[processors.rename]]
  namepass = ["mqtt_consumer"]
  [[processors.rename.replace]]
    measurement = "mqtt_consumer"
    dest = "enocean_sensors"

# Add derived metrics for switches
[[processors.starlark]]
  source = '''
def apply(metric):
    # Add button press duration tracking
    if metric.name == "enocean_sensors" and metric.tags.get("type") == "switch":
        if metric.fields.get("pressed") == 1:
            metric.fields["button_event"] = 1
        else:
            metric.fields["button_event"] = 0
            
    # Calculate heat index for temperature/humidity sensors
    if metric.name == "enocean_sensors" and metric.tags.get("type") in ["multi_sensor", "temp_humidity"]:
        temp_f = metric.fields.get("temperature_f")
        humidity = metric.fields.get("humidity_percent")
        
        if temp_f and humidity and temp_f >= 80:
            # Simplified heat index calculation
            hi = -42.379 + 2.04901523*temp_f + 10.14333127*humidity - 0.22475541*temp_f*humidity
            metric.fields["heat_index_f"] = hi
            metric.fields["heat_index_c"] = (hi - 32) * 5.0/9.0
            
    return metric
  '''
